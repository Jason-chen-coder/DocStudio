# NestJS 注册登录开发完整指南

本文档详细介绍如何在 NestJS + Prisma + PostgreSQL 技术栈中从零实现用户注册和登录功能。

## 1. 认证基础概念

### Session vs JWT

- **Session (会话)**: 服务端存储状态，客户端持有 Session ID。需要服务端存储 (Redis/内存)，难以横向扩展。
- **JWT (JSON Web Token)**: 无状态认证，服务端不存储，所有信息编码在 Token 中。适合分布式、微服务架构。

**本指南采用 JWT 方案。**

### JWT 结构

```
Header.Payload.Signature
```

- **Header**: 算法和类型 (`{ alg: "HS256", typ: "JWT" }`)
- **Payload**: 用户信息 (`{ userId: 1, email: "test@test.com" }`)
- **Signature**: 防篡改签名

## 2. 准备工作

### 安装依赖

```bash
pnpm add @nestjs/jwt @nestjs/passport passport passport-jwt bcryptjs
pnpm add -D @types/passport-jwt @types/bcryptjs
```

### Prisma Schema 定义

```prisma
// prisma/schema.prisma
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String   // 存储哈希后的密码
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

运行迁移：

```bash
npx prisma migrate dev --name add_user_model
```

## 3. 实现密码加密 (Bcrypt)

### 为什么用 Bcrypt？

- **不可逆**: 无法从哈希值还原密码。
- **加盐 (Salt)**: 防止彩虹表攻击。
- **慢速**: 故意设计得慢，防暴力破解。

### 在 UsersService 中实现

由于在实际业务中，我们通常需要一个专门的模块 (如 `UsersModule`) 来管理用户数据，我们可以将密码加密与验证逻辑收敛到 `UsersService` 中：

```typescript
import * as bcrypt from 'bcryptjs';
import { Injectable, ConflictException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class UsersService {
  constructor(private prisma: PrismaService) {}

  // 哈希密码并创建用户
  async create(email: string, name: string, password: string) {
    const existingUser = await this.prisma.user.findUnique({ where: { email } });
    if (existingUser) {
      throw new ConflictException('该邮箱已被注册');
    }

    const hashedPassword = await bcrypt.hash(password, 10);

    const user = await this.prisma.user.create({
      data: { email, name, password: hashedPassword },
    });

    const { password: _, ...result } = user;
    return result;
  }

  // 验证密码
  async validatePassword(plainPassword: string, hashedPassword: string): Promise<boolean> {
    return bcrypt.compare(plainPassword, hashedPassword);
  }

  // 附带密码信息查询用户供登录使用
  async findByEmailWithPassword(email: string) {
    return this.prisma.user.findUnique({ where: { email } });
  }
}
```

## 4. 创建 Auth 模块

### 生成资源

```bash
nest g module auth
nest g service auth
nest g controller auth
```

### 定义 DTO

创建 `src/auth/dto/register.dto.ts`:

```typescript
import { IsEmail, IsString, MinLength } from 'class-validator';

export class RegisterDto {
  @IsEmail()
  email: string;

  @IsString()
  @MinLength(8, { message: '密码至少 8 位' })
  password: string;

  @IsString()
  name: string;
}
```

创建 `src/auth/dto/login.dto.ts`:

```typescript
import { IsEmail, IsString } from 'class-validator';

export class LoginDto {
  @IsEmail()
  email: string;

  @IsString()
  password: string;
}
```

## 5. 实现 Auth Service

创建 `src/auth/auth.service.ts`，在这里我们将依赖刚刚定好的 `UsersService` 来完成密码封装与用户查找：

```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UsersService } from '../users/users.service';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService
  ) {}

  async register(registerDto: RegisterDto) {
    const { email, name, password } = registerDto;

    // 1. 由 UsersService 统一处理创建用户及密码哈希
    const user = await this.usersService.create(email, name, password);

    // 2. 生成 JWT token
    const payload = { sub: user.id, email: user.email };
    const access_token = this.jwtService.sign(payload);

    return {
      user,
      access_token,
    };
  }

  async login(loginDto: LoginDto) {
    const { email, password } = loginDto;

    // 1. 查找用户
    const user = await this.usersService.findByEmailWithPassword(email);
    if (!user || !user.password) {
      throw new UnauthorizedException('邮箱或密码错误');
    }

    // 2. 验证密码
    const isPasswordValid = await this.usersService.validatePassword(password, user.password);

    if (!isPasswordValid) {
      throw new UnauthorizedException('邮箱或密码错误');
    }

    // 3. 生成 JWT token
    const payload = { sub: user.id, email: user.email };
    const access_token = this.jwtService.sign(payload);

    // 4. 返回用户信息（不包含密码）
    const { password: _, ...userWithoutPassword } = user;

    return {
      user: userWithoutPassword,
      access_token,
    };
  }
}
```

## 6. 配置 JWT Module

修改 `src/auth/auth.module.ts`:

```typescript
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [
    PrismaModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET || 'your-secret-key', // 生产环境必须用环境变量
      signOptions: { expiresIn: '7d' }, // Token 有效期 7 天
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService],
})
export class AuthModule {}
```

**安全提示**: `JWT_SECRET` 应存放在 `.env` 中，永远不要硬编码。

## 7. 实现 Auth Controller

创建 `src/auth/auth.controller.ts`:

```typescript
import { Controller, Post, Body } from '@nestjs/common';
import { AuthService } from './auth.service';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('register')
  async register(@Body() dto: RegisterDto) {
    return this.authService.register(dto);
  }

  @Post('login')
  async login(@Body() dto: LoginDto) {
    return this.authService.login(dto);
  }
}
```

此时你的 API 已经可以工作：

- `POST /auth/register` - 注册
- `POST /auth/login` - 登录

## 8. 实现 JWT 认证守卫 (Guard)

### 创建 JWT Strategy

创建 `src/auth/strategies/jwt.strategy.ts`:

```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PrismaService } from '../../prisma/prisma.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private prisma: PrismaService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), // 从 Authorization: Bearer <token> 提取
      secretOrKey: process.env.JWT_SECRET || 'your-secret-key',
    });
  }

  // 验证 Token 后调用，payload 是解码后的 JWT 内容
  async validate(payload: { sub: number; email: string }) {
    const user = await this.prisma.user.findUnique({
      where: { id: payload.sub },
    });
    if (!user) {
      throw new UnauthorizedException('用户不存在');
    }
    return user; // 会被注入到 Request 对象的 user 属性
  }
}
```

### 创建 JWT Guard

创建 `src/auth/guards/jwt-auth.guard.ts`:

```typescript
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}
```

### 注册 Strategy

修改 `src/auth/auth.module.ts`，添加 `JwtStrategy` 到 `providers`:

```typescript
import { JwtStrategy } from './strategies/jwt.strategy';

@Module({
  // ...
  providers: [AuthService, JwtStrategy],
  exports: [JwtStrategy], // 导出供其他模块使用
})
export class AuthModule {}
```

## 9. 保护路由（需要登录才能访问）

使用 `@UseGuards(JwtAuthGuard)` 装饰器保护路由。

示例：创建一个需要认证的 `/users/profile` 接口。

```typescript
import { Controller, Get, UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { CurrentUser } from '../common/decorators/current-user.decorator';
import { User } from '@prisma/client';

@Controller('users')
export class UsersController {
  @Get('profile')
  @UseGuards(JwtAuthGuard) // 必须登录
  getProfile(@CurrentUser() user: User) {
    return {
      id: user.id,
      email: user.email,
      name: user.name,
    };
  }
}
```

## 10. 创建自定义装饰器获取当前用户

创建 `src/common/decorators/current-user.decorator.ts`:

```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const CurrentUser = createParamDecorator((data: unknown, ctx: ExecutionContext) => {
  const request = ctx.switchToHttp().getRequest();
  return request.user; // JwtStrategy 的 validate 返回值
});
```

## 11. 完整流程总结

### 注册流程

1. 前端发送 `POST /auth/register` (email, password, name)
2. 后端验证 DTO (邮箱格式、密码长度)
3. 交由 `UsersService` 检查邮箱是否已存在，并使用 `bcryptjs` 哈希密码
4. `UsersService` 执行创建操作并保存用户到数据库
5. `AuthService` 接管并生成 JWT Token 随后返回

### 登录流程

1. 前端发送 `POST /auth/login` (email, password)
2. 后端由 `UsersService` 根据邮箱获取带密码信息的用户
3. 再次由 `UsersService` 调用 `bcryptjs` 验证输入密码与数据库中密码哈希
4. 当验证通过后，`AuthService` 生成 JWT Token 连同用户信息一并返回

### 访问受保护资源流程

1. 前端在请求头中携带 `Authorization: Bearer <token>`
2. `JwtAuthGuard` 拦截请求
3. `JwtStrategy` 验证 Token 并解码 Payload
4. 通过 `payload.sub` (userId) 查询用户
5. 将用户对象注入到 `request.user`
6. 控制器通过 `@CurrentUser()` 获取用户信息

## 12. 安全最佳实践

- **密码强度**: 要求至少 8 位，包含大小写字母、数字、特殊字符。
- **JWT Secret**: 使用长随机字符串，存储在环境变量中。
- **Token 过期时间**: 不要设置太长 (推荐 7-15 天)，敏感操作要求重新认证。
- **HTTPS**: 生产环境必须使用 HTTPS，防止 Token 被窃听。
- **刷新 Token**: 实现 Refresh Token 机制，延长用户登录状态而不泄露长效 Token。
- **速率限制**: 使用 `@nestjs/throttler` 防止暴力破解。
- **排除敏感字段**: 返回用户信息时永远不要返回 `password` 字段。

## 13. 测试接口

使用 Postman 或 cURL 测试：

```bash
# 注册
curl -X POST http://localhost:3000/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"12345678","name":"Test User"}'

# 登录
curl -X POST http://localhost:3000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"12345678"}'

# 获取个人信息 (需要替换 <YOUR_TOKEN>)
curl -X GET http://localhost:3000/users/profile \
  -H "Authorization: Bearer <YOUR_TOKEN>"
```
