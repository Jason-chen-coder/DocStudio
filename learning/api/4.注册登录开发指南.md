# NestJS 注册登录开发完整指南

本文档详细介绍如何在 NestJS + Prisma + PostgreSQL 技术栈中从零实现用户注册和登录功能。

## 1. 认证基础概念

### Session vs JWT

- **Session (会话)**: 服务端存储状态，客户端持有 Session ID。需要服务端存储 (Redis/内存)，难以横向扩展。
- **JWT (JSON Web Token)**: 无状态认证，服务端不存储，所有信息编码在 Token 中。适合分布式、微服务架构。

**本指南采用 JWT 方案。**

### JWT 结构

```
Header.Payload.Signature
```

- **Header**: 算法和类型 (`{ alg: "HS256", typ: "JWT" }`)
- **Payload**: 用户信息 (`{ userId: 1, email: "test@test.com" }`)
- **Signature**: 防篡改签名

## 2. 准备工作

### 安装依赖

```bash
pnpm add @nestjs/jwt @nestjs/passport passport passport-jwt bcrypt
pnpm add -D @types/passport-jwt @types/bcrypt
```

### Prisma Schema 定义

```prisma
// prisma/schema.prisma
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  password  String   // 存储哈希后的密码
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

运行迁移：

```bash
npx prisma migrate dev --name add_user_model
```

## 3. 实现密码加密 (Bcrypt)

### 为什么用 Bcrypt？

- **不可逆**: 无法从哈希值还原密码。
- **加盐 (Salt)**: 防止彩虹表攻击。
- **慢速**: 故意设计得慢，防暴力破解。

### 封装加密工具

创建 `src/common/utils/hash.util.ts`:

```typescript
import * as bcrypt from 'bcrypt';

const SALT_ROUNDS = 10; // 盐的成本因子，越大越安全但越慢

export async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, SALT_ROUNDS);
}

export async function comparePassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}
```

## 4. 创建 Auth 模块

### 生成资源

```bash
nest g module auth
nest g service auth
nest g controller auth
```

### 定义 DTO

创建 `src/auth/dto/register.dto.ts`:

```typescript
import { IsEmail, IsString, MinLength } from 'class-validator';

export class RegisterDto {
  @IsEmail()
  email: string;

  @IsString()
  @MinLength(8, { message: '密码至少 8 位' })
  password: string;

  @IsString()
  name: string;
}
```

创建 `src/auth/dto/login.dto.ts`:

```typescript
import { IsEmail, IsString } from 'class-validator';

export class LoginDto {
  @IsEmail()
  email: string;

  @IsString()
  password: string;
}
```

## 5. 实现 Auth Service

创建 `src/auth/auth.service.ts`:

```typescript
import { Injectable, UnauthorizedException, ConflictException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../prisma/prisma.service';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';
import { hashPassword, comparePassword } from '../common/utils/hash.util';

@Injectable()
export class AuthService {
  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService
  ) {}

  // 注册
  async register(dto: RegisterDto) {
    // 1. 检查邮箱是否已存在
    const existing = await this.prisma.user.findUnique({
      where: { email: dto.email },
    });
    if (existing) {
      throw new ConflictException('邮箱已被注册');
    }

    // 2. 哈希密码
    const hashedPassword = await hashPassword(dto.password);

    // 3. 创建用户
    const user = await this.prisma.user.create({
      data: {
        email: dto.email,
        password: hashedPassword,
        name: dto.name,
      },
    });

    // 4. 生成 JWT Token
    return this.generateToken(user.id, user.email);
  }

  // 登录
  async login(dto: LoginDto) {
    // 1. 查找用户
    const user = await this.prisma.user.findUnique({
      where: { email: dto.email },
    });
    if (!user) {
      throw new UnauthorizedException('邮箱或密码错误');
    }

    // 2. 验证密码
    const isValid = await comparePassword(dto.password, user.password);
    if (!isValid) {
      throw new UnauthorizedException('邮箱或密码错误');
    }

    // 3. 生成 JWT Token
    return this.generateToken(user.id, user.email);
  }

  // 生成 Token
  private generateToken(userId: number, email: string) {
    const payload = { sub: userId, email }; // sub 是 JWT 标准字段，表示 subject
    return {
      access_token: this.jwtService.sign(payload),
    };
  }
}
```

## 6. 配置 JWT Module

修改 `src/auth/auth.module.ts`:

```typescript
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  imports: [
    PrismaModule,
    JwtModule.register({
      secret: process.env.JWT_SECRET || 'your-secret-key', // 生产环境必须用环境变量
      signOptions: { expiresIn: '7d' }, // Token 有效期 7 天
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService],
})
export class AuthModule {}
```

**安全提示**: `JWT_SECRET` 应存放在 `.env` 中，永远不要硬编码。

## 7. 实现 Auth Controller

创建 `src/auth/auth.controller.ts`:

```typescript
import { Controller, Post, Body } from '@nestjs/common';
import { AuthService } from './auth.service';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('register')
  async register(@Body() dto: RegisterDto) {
    return this.authService.register(dto);
  }

  @Post('login')
  async login(@Body() dto: LoginDto) {
    return this.authService.login(dto);
  }
}
```

此时你的 API 已经可以工作：

- `POST /auth/register` - 注册
- `POST /auth/login` - 登录

## 8. 实现 JWT 认证守卫 (Guard)

### 创建 JWT Strategy

创建 `src/auth/strategies/jwt.strategy.ts`:

```typescript
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { PrismaService } from '../../prisma/prisma.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(private prisma: PrismaService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), // 从 Authorization: Bearer <token> 提取
      secretOrKey: process.env.JWT_SECRET || 'your-secret-key',
    });
  }

  // 验证 Token 后调用，payload 是解码后的 JWT 内容
  async validate(payload: { sub: number; email: string }) {
    const user = await this.prisma.user.findUnique({
      where: { id: payload.sub },
    });
    if (!user) {
      throw new UnauthorizedException('用户不存在');
    }
    return user; // 会被注入到 Request 对象的 user 属性
  }
}
```

### 创建 JWT Guard

创建 `src/auth/guards/jwt-auth.guard.ts`:

```typescript
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}
```

### 注册 Strategy

修改 `src/auth/auth.module.ts`，添加 `JwtStrategy` 到 `providers`:

```typescript
import { JwtStrategy } from './strategies/jwt.strategy';

@Module({
  // ...
  providers: [AuthService, JwtStrategy],
  exports: [JwtStrategy], // 导出供其他模块使用
})
export class AuthModule {}
```

## 9. 保护路由（需要登录才能访问）

使用 `@UseGuards(JwtAuthGuard)` 装饰器保护路由。

示例：创建一个需要认证的 `/users/profile` 接口。

```typescript
import { Controller, Get, UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { CurrentUser } from '../common/decorators/current-user.decorator';
import { User } from '@prisma/client';

@Controller('users')
export class UsersController {
  @Get('profile')
  @UseGuards(JwtAuthGuard) // 必须登录
  getProfile(@CurrentUser() user: User) {
    return {
      id: user.id,
      email: user.email,
      name: user.name,
    };
  }
}
```

## 10. 创建自定义装饰器获取当前用户

创建 `src/common/decorators/current-user.decorator.ts`:

```typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const CurrentUser = createParamDecorator((data: unknown, ctx: ExecutionContext) => {
  const request = ctx.switchToHttp().getRequest();
  return request.user; // JwtStrategy 的 validate 返回值
});
```

## 11. 完整流程总结

### 注册流程

1. 前端发送 `POST /auth/register` (email, password, name)
2. 后端验证 DTO (邮箱格式、密码长度)
3. 检查邮箱是否已存在
4. 使用 bcrypt 哈希密码
5. 保存用户到数据库
6. 生成 JWT Token 并返回

### 登录流程

1. 前端发送 `POST /auth/login` (email, password)
2. 后端查找用户
3. 使用 bcrypt 验证密码
4. 生成 JWT Token 并返回

### 访问受保护资源流程

1. 前端在请求头中携带 `Authorization: Bearer <token>`
2. `JwtAuthGuard` 拦截请求
3. `JwtStrategy` 验证 Token 并解码 Payload
4. 通过 `payload.sub` (userId) 查询用户
5. 将用户对象注入到 `request.user`
6. 控制器通过 `@CurrentUser()` 获取用户信息

## 12. 安全最佳实践

- **密码强度**: 要求至少 8 位，包含大小写字母、数字、特殊字符。
- **JWT Secret**: 使用长随机字符串，存储在环境变量中。
- **Token 过期时间**: 不要设置太长 (推荐 7-15 天)，敏感操作要求重新认证。
- **HTTPS**: 生产环境必须使用 HTTPS，防止 Token 被窃听。
- **刷新 Token**: 实现 Refresh Token 机制，延长用户登录状态而不泄露长效 Token。
- **速率限制**: 使用 `@nestjs/throttler` 防止暴力破解。
- **排除敏感字段**: 返回用户信息时永远不要返回 `password` 字段。

## 13. 测试接口

使用 Postman 或 cURL 测试：

```bash
# 注册
curl -X POST http://localhost:3000/auth/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"12345678","name":"Test User"}'

# 登录
curl -X POST http://localhost:3000/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"12345678"}'

# 获取个人信息 (需要替换 <YOUR_TOKEN>)
curl -X GET http://localhost:3000/users/profile \
  -H "Authorization: Bearer <YOUR_TOKEN>"
```
