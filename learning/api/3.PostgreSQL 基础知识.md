# PostgreSQL 基础与实战指南

PostgreSQL (简称 Postgres) 是世界上最先进的开源关系型数据库。它以稳定性、功能丰富和遵循 SQL 标准而闻名。

## 1. 核心概念 (Core Concepts)

### 逻辑结构

- **Database (数据库)**: 数据的容器。一个实例可以包含多个 Databases。
- **Schema (模式)**: 数据库内的命名空间（类似文件夹）。默认 Schema 是 `public`。
  - 引用表: `database.schema.table` (例如 `my_app.public.users`)。
- **Table (表)**: 行列数据的集合。
- **Row (行)**: 一条记录。
- **Column (列)**: 字段。

### 关键特性

- **ACID 兼容**: 保证事务的原子性、一致性、隔离性和持久性。
- **JSONB 支持**: 允许存储和查询 JSON 数据（NoSQL 能力），支持索引。
- **扩展性**: 支持 PostGIS (地理信息), pgvector (向量搜索) 等插件。

## 2. 常用 SQL 命令速查

### DDL (数据定义语言) - 管理结构

```sql
-- 创建数据库
CREATE DATABASE my_app;

-- 创建表
CREATE TABLE users (
    id SERIAL PRIMARY KEY, -- 自增主键
    email VARCHAR(255) UNIQUE NOT NULL,
    metadata JSONB,        -- 存放非结构化数据
    created_at TIMESTAMP DEFAULT NOW()
);

-- 修改表
ALTER TABLE users ADD COLUMN age INT;

-- 创建索引 (提升查询速度)
CREATE INDEX idx_users_email ON users(email);
-- 创建 JSONB 索引 (GIN 索引)
CREATE INDEX idx_users_metadata ON users USING GIN (metadata);
```

### DML (数据操作语言) - 管理数据

```sql
-- 插入
INSERT INTO users (email, metadata)
VALUES ('test@example.com', '{"role": "admin"}');

-- 查询
SELECT * FROM users WHERE email = 'test@example.com';
-- 查询 JSONB
SELECT * FROM users WHERE metadata->>'role' = 'admin';

-- 更新
UPDATE users SET age = 30 WHERE id = 1;

-- 删除
DELETE FROM users WHERE id = 1;
```

## 3. 常用 CLI 命令 (psql)

通过命令行工具 `psql` 连接数据库时常用：

- `\l`: 列出所有数据库。
- `\c <dbname>`: 连接到指定数据库。
- `\dt`: 列出当前 Schema 下的所有表。
- `\d <table>`: 查看表结构（字段、索引、约束）。
- `\du`: 列出所有用户/角色。
- `\q`: 退出。

## 4. Docker 快速启动

在本地开发中最方便的方式是使用 Docker。

```bash
docker run --name pg-local \
  -e POSTGRES_USER=postgres \
  -e POSTGRES_PASSWORD=password \
  -e POSTGRES_DB=mydb \
  -p 5432:5432 \
  -d postgres:15
```

对应连接 URL: `postgresql://postgres:password@localhost:5432/mydb`

## 5. PostgreSQL x Prisma 实战集成

在使用 Prisma 连接 Postgres 时，有一些特定的配置和优势。

### 连接字符串配置

在 `.env` 文件中配置 `DATABASE_URL`：

```env
# 格式: postgresql://USER:PASSWORD@HOST:PORT/DATABASE?schema=SCHEMA
DATABASE_URL="postgresql://postgres:password@localhost:5432/mydb?schema=public"
```

- `schema`: 默认为 `public`。如果你在使用多租户或其他模式，可以在此修改。
- `connection_limit`: 连接池大小配置（可选，例如 `&connection_limit=5`）。

### 类型映射 (Type Mapping)

PostgreSQL 的丰富类型在 Prisma Schema 中的对应关系：

| Postgres Type     | Prisma Type | 说明                 |
| :---------------- | :---------- | :------------------- |
| `INT`, `SERIAL`   | `Int`       | 整数                 |
| `BIGINT`          | `BigInt`    | 大整数               |
| `VARCHAR`, `TEXT` | `String`    | 文本                 |
| `BOOLEAN`         | `Boolean`   | 布尔值               |
| `TIMESTAMP`       | `DateTime`  | 时间戳               |
| `JSONB`           | `Json`      | 结构化 JSON 数据     |
| `ARRAY`           | `type[]`    | 数组 (如 `String[]`) |
| `ENUM`            | `enum`      | 原生枚举类型         |

### 特有功能实战

#### 1. 使用 JSONB (NoSQL 能力)

Postgres 的 JSONB 是其杀手级特性，Prisma 完美支持。

```prisma
// schema.prisma
model Log {
  id      Int  @id @default(autoincrement())
  payload Json // 对应 Postgres JSONB
}
```

```typescript
// 使用
await prisma.log.create({
  data: {
    payload: { action: 'login', ip: '192.168.1.1' }, // 自动序列化
  },
});

// JSON 过滤 (Postgres 特有)
await prisma.log.findMany({
  where: {
    payload: {
      path: ['action'],
      equals: 'login',
    },
  },
});
```

#### 2. 使用原生数组 (Arrays)

Postgres 支持数组类型，这在存标签 (Tags) 时非常有用。

```prisma
// schema.prisma
model Post {
  id   Int      @id @default(autoincrement())
  tags String[] // 对应 Postgres text[]
}
```

```typescript
// 使用
await prisma.post.create({
  data: {
    tags: ['nextjs', 'postgres'],
  },
});

// 数组包含查询
await prisma.post.findMany({
  where: {
    tags: { has: 'nextjs' },
  },
});
```

#### 3. 使用原生枚举 (Native Enums)

```prisma
// schema.prisma
enum Role {
  USER
  ADMIN
}

model User {
  id   Int  @id @default(autoincrement())
  role Role @default(USER) // 对应数据库层面的 TYPE Role AS ENUM (...)
}
```

这比仅在应用层验证枚举更安全，因为数据库会拒绝非法值。

## 6. 最佳实践

- **永远使用主键**: 每个表都应该有一个 PRIMARY KEY。
- **使用外键约束**: 保证数据引用的一致性 (Foreign Keys)。
- **小心 N+1 问题**: 在应用层（如 Prisma/TypeORM）查询时注意避免循环查询。
- **定期 VACUUM**: Postgres 使用 MVCC，删除的数据只是标记为无效，需要定期清理（Auto-vacuum 通常会自动处理）。
