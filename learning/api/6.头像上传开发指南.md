# 头像上传功能开发核心指南

本文档总结了 DocStudio 项目中用户头像上传功能的完整开发流程与核心技术点。该功能涉及前端组件交互、后端文件流处理以及 MinIO 对象存储的集成。

## 1. 核心流程概览

整个流程是个典型的**文件上传 + 数据更新**链路：

1.  **前端 (Frontend)**: 用户选择图片 -> 封装 `FormData` -> 调用 API。
2.  **后端 (Backend)**: 接收 `multipart/form-data` 请求 -> 解析文件流 -> 上传至 MinIO -> 获取文件**相对路径**。
3.  **数据库 (Database)**: 将 MinIO 返回的相对路径(如 `avatars/xyz.jpg`) 更新到 `User` 表的 `avatarUrl` 字段。
4.  **回显 (Feedback)**: 后端在返回用户数据前，**动态拼接**完整 URL -> 前端获取到完整 URL -> UI 实时刷新。

---

## 2. 前端实现 (Frontend)

对于前端开发工程师，核心关注点在于如何处理文件输入、API 调用以及状态更新。

### 2.1 文件选择与 FormData

使用隐藏的 `<input type="file" />` 结合 useRef 触发选择。

```typescript
// apps/web/src/components/avatar-upload.tsx

const handleFileChange = async (event: React.ChangeEvent<HTMLInputElement>) => {
  const file = event.target.files?.[0];
  if (!file) return;

  // 1. 客户端校验 (类型 & 大小)
  if (!file.type.startsWith('image/')) {
    alert('请选择图片文件');
    return;
  }

  // 2. 调用 API
  await upload(file);
};
```

**API 调用的关键：** Browser 原生的 `FormData` 对象。

```typescript
// apps/web/src/lib/api.ts

export const authAPI = {
  uploadAvatar: async (file: File) => {
    const formData = new FormData();
    formData.append('file', file); // 'file' 必须与后端 @Fastify/multipart 的字段名一致

    // 发送请求，Content-Type 设为 undefined，让浏览器自动设置 multipart/form-data boundary
    return apiRequest('/users/avatar', {
      method: 'POST',
      body: formData,
    });
  },
};
```

### 2.2 状态更新 (Optimistic UI)

为了提供丝滑的体验，上传成功后不仅要提示成功，还要立即更新 UI 中的头像，而不需要用户手动刷新页面。

我们利用 `AuthContext` 提供的 `updateUser` 方法：

```typescript
// apps/web/src/components/avatar-upload.tsx

const { updateUser } = useAuth();

// ...上传成功后
const updatedUser = await authAPI.uploadAvatar(file);
updateUser(updatedUser); // 立即更新全局 User 对象，Header 和 Profile 页面的头像会自动变更
```

### 2.3 头像 URL 处理

**注意点**：虽然数据库存的是相对路径，但后端接口 (`UsersService`) 会在返回数据前自动拼接 `MINIO_PUBLIC_ENDPOINT`，所以**前端接收到的通常是绝对路径**。

为了兼容性（防止后端没配置好或旧数据），前端保留了如下兼容处理：

```typescript
// apps/web/src/components/layout/header.tsx

const avatarUrl = user?.avatarUrl
  ? user.avatarUrl.startsWith('http')
    ? user.avatarUrl // 已经是绝对路径 (MinIO)
    : `${process.env.NEXT_PUBLIC_API_URL}${user.avatarUrl}` // 相对路径 (兼容旧版)
  : undefined;
```

---

## 3. 后端实现 (Backend - NestJS)

后端主要负责接收文件流、转存对象存储、以及 URL 的动态拼接。

### 3.1 处理 Multipart 请求

由于使用了 Fastify 作为底层框架，我们需要 `@fastify/multipart` 插件。

```typescript
// apps/api/src/users/users.controller.ts

@Post('avatar')
@UseGuards(AuthGuard('jwt'))
async uploadAvatar(@Req() req: RequestWithUser) {
  const fastifyReq = req as any;
  if (!fastifyReq.isMultipart()) throw new BadRequestException('Request is not multipart');

  const part = await fastifyReq.file();
  const fileBuffer = await part.toBuffer();

  // ...调用 Service 上传
}
```

### 3.2 MinIO 集成 (对象存储)

我们封装了 `MinioService` 来屏蔽底层细节。**关键变更：`uploadFile` 现在返回相对路径**。

```typescript
// apps/api/src/common/minio/minio.service.ts

async uploadFile(filename: string, fileBuffer: Buffer, mimetype: string) {
  await this.minioClient.putObject(...);

  // 返回相对路径: bucket/filename
  // 例如: avatars/abc-123.jpg
  return `${this.bucketName}/${filename}`;
}
```

### 3.3 数据转换 (URL 拼接)

在 `UsersService` 中，我们实现了 `transformUser` 方法，在返回用户信息给前端前，动态拼接完整 URL。

```typescript
// apps/api/src/users/users.service.ts

private transformUser(user: any) {
  if (user.avatarUrl && !user.avatarUrl.startsWith('http')) {
    // 拼接环境变量中配置的 Public Endpoint
    const baseUrl = process.env.MINIO_PUBLIC_ENDPOINT || 'http://localhost:9000';
    user.avatarUrl = `${baseUrl}/${user.avatarUrl}`;
  }
  return user;
}
```

这样做的好处是，如果 MinIO 的域名变更（如从 localhost 变为 OSS 域名），只需修改环境变量，数据库里的数据无需刷库。

---

## 4. 基础设施 (Infrastructure)

### 4.1 Docker Compose

我们使用 MinIO 容器作为 S3 兼容的对象存储服务。

```yaml
# docker-compose.yml
services:
  minio:
    image: minio/minio
    ports:
      - '9000:9000' # API 端口
      - '9001:9001' # Console 管理界面端口
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    command: server /data --console-address ":9001"
```

### 4.2 环境变量 (.env)

新增了 `MINIO_PUBLIC_ENDPOINT` 配置。

**API (.env):**

```bash
MINIO_ENDPOINT=localhost
MINIO_PORT=9000
MINIO_ACCESS_KEY=minioadmin
MINIO_SECRET_KEY=minioadmin
MINIO_BUCKET=avatars
# 新增：前端访问 MinIO 的公开地址
MINIO_PUBLIC_ENDPOINT=http://localhost:9000
```

---

## 5. 总结

通过这次重构，我们将文件存储从**本地磁盘**迁移到了**对象存储 (MinIO)**。

- **存储策略**: 数据库仅存储**相对路径**，实现与域名解耦。
- **API 策略**: 后端动态拼接完整 URL，保证前端使用的便捷性。
- **扩展性**: 未来如果要迁移到 AWS S3 或阿里云 OSS，只需替换 MinIO 配置和 `MINIO_PUBLIC_ENDPOINT` 即可，代码和数据无需大改。
